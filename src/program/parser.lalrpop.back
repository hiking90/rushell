use std::str::FromStr;
use crate::program::ast;
use crate::program::lexer;
use lalrpop_util::{ErrorRecovery, ParseError};

grammar<'err, 'input>(errors: &'err mut Vec<ErrorRecovery<usize, lexer::Tok<'input>, lexer::Error>>);

extern {
    type Location = usize;
    type Error = lexer::Error;

    enum lexer::Tok<'input> {
        " "         => lexer::Tok::Space,
        "["         => lexer::Tok::LBracket,
        "]"         => lexer::Tok::RBracket,
        "[["        => lexer::Tok::LDBracket,
        "]]"        => lexer::Tok::RDBracket,
        "="         => lexer::Tok::Equals,
        "=+"        => lexer::Tok::EqualsPlus,
        "=="        => lexer::Tok::DEquals,
        "=~"        => lexer::Tok::EqualsTilde,
        "&"         => lexer::Tok::Amp,
        ";"         => lexer::Tok::Semi,
        "|"         => lexer::Tok::Or,
        "||"        => lexer::Tok::OrIf,
        "&&"        => lexer::Tok::AndIf,
        "\""        => lexer::Tok::DoubleQuoted,
        "'"         => lexer::Tok::SingleQuoted,
        "`"         => lexer::Tok::Backtick,
        "$("        => lexer::Tok::CommandSpan,
        "$(("       => lexer::Tok::LExprSpan,
        "))"        => lexer::Tok::RExprSpan,
        "("         => lexer::Tok::LParen,
        ")"         => lexer::Tok::RParen,
        "$"         => lexer::Tok::Dollar,
        "!"         => lexer::Tok::Bang,
        "!="        => lexer::Tok::BangEquals,
        "${"        => lexer::Tok::ParamEx,
        "{"         => lexer::Tok::LBrace,
        "}"         => lexer::Tok::RBrace,
        "\n"        => lexer::Tok::Linefeed,

        "&>"        => lexer::Tok::AndGreat,
        ">&"        => lexer::Tok::GreatAnd,
        "&>>"       => lexer::Tok::AndDGreat,

        "n>&n"      => lexer::Tok::NLessAndN(<(char, char)>),

        ">"         => lexer::Tok::Great,
        ">>"        => lexer::Tok::DGreat,
        ">|"        => lexer::Tok::Clobber,
        "<"         => lexer::Tok::Less,
        "<<"        => lexer::Tok::DLess,
        "<<-"       => lexer::Tok::DLessDash,
        "<&"        => lexer::Tok::LessAnd,
        "<>"        => lexer::Tok::LessGreat,

        "n<"        => lexer::Tok::NLess(<char>),
        "n<<"       => lexer::Tok::NDLess(<char>),
        "n>"        => lexer::Tok::NGreat(<char>),
        "n>>"       => lexer::Tok::NDGreat(<char>),
        "n>|"       => lexer::Tok::NClobber(<char>),

        "if"        => lexer::Tok::If,
        "then"      => lexer::Tok::Then,
        "fi"        => lexer::Tok::Fi,
        "elif"      => lexer::Tok::Elif,
        "else"      => lexer::Tok::Else,

        "while"     => lexer::Tok::While,
        "do"        => lexer::Tok::Do,
        "done"      => lexer::Tok::Done,

        "-?"        => lexer::Tok::DashOp(<char>),
        "-gt"       => lexer::Tok::GT,
        "-lt"       => lexer::Tok::LT,
        "-ge"       => lexer::Tok::GE,
        "-le"       => lexer::Tok::LE,
        "-eq"       => lexer::Tok::EQ,
        "-ne"       => lexer::Tok::NE,
        "-nt"       => lexer::Tok::NT,
        "-ot"       => lexer::Tok::OT,
        "-ef"       => lexer::Tok::EF,

        "TEXT"      => lexer::Tok::Text(<&'input str>),
    }
}


pub Program: ast::Program = {
    linebreak <cmds: CompleteCommands> linebreak => ast::Program { terms: <> },
    linebreak => ast::Program { terms: vec![] },
     // Term => ast::Program { terms: <> },
}

CompleteCommands: Vec<ast::Term> = {
    <mut cmds: CompleteCommands> newline_list <cmd: CompleteCommand> => {
        cmds.extend(cmd);
        cmds
    },
    CompleteCommand,
}

CompleteCommand: Vec<ast::Term> = {
    <mut l: List> <bg: separator_op> => {
        let last = l.last_mut().unwrap();
        last.background = bg;
        l
    },
    List => <>,
}

separator_op: bool = {
    "&" => true,
    ";" => false,
}

separator: bool = {
    <bg: separator_op> linebreak => bg,
    newline_list => false,
}

List: Vec<ast::Term> = {
    <mut l: List> <bg: separator_op> <ao: AndOr> => {
        let last = l.last_mut().unwrap();
        last.background = bg;
        l.push(ao);
        l
    },
    AndOr => vec![<>],
}

linebreak: () = {
    newline_list?,
}

newline_list: () = {
    "\n",
    newline_list "\n",
}


AndOr: ast::Term = {
    <mut ao: AndOr> "||" linebreak <mut pl: Pipeline> => {
        pl.run_if = ast::RunIf::Failure;
        ao.pipelines.push(pl);
        ao
    },

    <mut ao: AndOr> "&&" linebreak <mut pl: Pipeline> => {
        pl.run_if = ast::RunIf::Success;
        ao.pipelines.push(pl);
        ao
    },

    Pipeline => ast::Term {
        pipelines: vec![<>],
        background: false,
    },
}

Pipeline: ast::Pipeline = {
    PipeSequence => <>,
    "!" <ps: PipeSequence> => ps,       // TODO
}

PipeSequence: ast::Pipeline = {
    <mut pl: PipeSequence> "|" linebreak <c: Command> => {
        pl.commands.push(c);
        pl
    },
    Command => {
        ast::Pipeline {
            run_if: ast::RunIf::Always,
            commands: vec![<>],
        }
    }
}

Command: ast::Command = {
    SimpleCommand => <>,
    CompoundCommand => <>,
    ConditionCommand => <>,
}

CompoundCommand: ast::Command = {
    IfClause => <>,
    WhileClause => <>,
    SubShell => <>,
}

SubShell: ast::Command = {
    "(" <terms: CompoundList> ")" => ast::Command::SubShellGroup { terms: terms },
}

CompoundList: Vec<ast::Term> = {
    linebreak <t: Term> => t,
    linebreak <mut t: Term> <bg: separator> => {
        let last = t.last_mut().unwrap();
        last.background = bg;
        t
    },
}

Term: Vec<ast::Term> = {
    <mut t: Term> <bg: separator> <ao: AndOr> => {
        let last = t.last_mut().unwrap();
        last.background = bg;
        t.push(ao);
        t
    },
    AndOr => vec![<>],
}

ConditionCommand: ast::Command = {
    "[[" <is_not: "!"?> <expr: CondExpr> "]]" => {
        ast::Command::Cond {
            is_not: is_not.is_some(),
            expr: None,
        }
    }
}

CondExpr: Box<ast::CondExpr> = {
    <lhs: CondExpr> "||" <rhs: CondTerm> => Box::new(ast::CondExpr::Or(lhs, rhs)),
    <lhs: CondExpr> "&&" <rhs: CondTerm> => Box::new(ast::CondExpr::And(lhs, rhs)),
    CondTerm,
}

CondTerm: Box<ast::CondExpr> = {
    <op: CondPrimaryOp> <lhs: CondPrimary> => {
        match op {
            'z' => Box::new(ast::CondExpr::StrEq(lhs, Box::new(ast::CondExpr::Word(ast::Word(vec![ast::Span::Literal("".into())]))))),
            'n' => Box::new(ast::CondExpr::StrNe(lhs, Box::new(ast::CondExpr::Word(ast::Word(vec![ast::Span::Literal("".into())]))))),
            'a' | 'd' | 'e' | 'f' | 'h' | 's' | 'L' | 'N' => Box::new(ast::CondExpr::File(lhs, format!("-{}", op))),
            // "-b" | "-c" | "-g" |
            // "-k" | "-p" | "-r" | "-t" | "-u" |
            // "-w" | "-x" | "-O" | "-G" |
            // "-S" => unimplemented!(),
            _ => unreachable!(),
        }
    },

    <lhs: CondPrimary> "=~" <text: "TEXT"> => Box::new(ast::CondExpr::Regex(lhs, text.into())),

    CondPrimary => <>,

    <lhs: CondPrimary> "-eq" <rhs: CondTerm>  => Box::new(ast::CondExpr::Eq(lhs, rhs)),
    <lhs: CondPrimary> "-ne" <rhs: CondTerm>  => Box::new(ast::CondExpr::Ne(lhs, rhs)),
    <lhs: CondPrimary> "-lt" <rhs: CondTerm> => Box::new(ast::CondExpr::Lt(lhs, rhs)),
    <lhs: CondPrimary> "<" <rhs: CondTerm> => Box::new(ast::CondExpr::Lt(lhs, rhs)),
    <lhs: CondPrimary> "-le" <rhs: CondTerm>  => Box::new(ast::CondExpr::Le(lhs, rhs)),
    <lhs: CondPrimary> "-gt" <rhs: CondTerm>  => Box::new(ast::CondExpr::Gt(lhs, rhs)),
    <lhs: CondPrimary> ">" <rhs: CondTerm>  => Box::new(ast::CondExpr::Gt(lhs, rhs)),
    <lhs: CondPrimary> "-ge" <rhs: CondTerm>  => Box::new(ast::CondExpr::Ge(lhs, rhs)),
    <lhs: CondPrimary> "=="  <rhs: CondTerm> => Box::new(ast::CondExpr::StrEq(lhs, rhs)),
    <lhs: CondPrimary> "="  <rhs: CondTerm> => Box::new(ast::CondExpr::StrEq(lhs, rhs)),
    <lhs: CondPrimary> "!="  <rhs: CondTerm> => Box::new(ast::CondExpr::StrNe(lhs, rhs)),
}

CondPrimaryOp: char = {
    <op: "-?"> => op,
}

CondPrimary: Box<ast::CondExpr> = {
    "(" <expr: CondExpr> ")" => expr,
    Word => Box::new(ast::CondExpr::Word(<>)),
}

WhileClause: ast::Command = {
    "while" <condition: CompoundList> "do" <body: CompoundList> "done" => {
        ast::Command::While {
            condition: condition,
            body: body,
        }
    }
}

IfClause: ast::Command = {
    "if" <condition: CompoundList> "then" <then_part: CompoundList> <elif_parts: ElifPart*> <else_part: ElsePart?> "fi" => {
        ast::Command::If {
            condition: condition,
            then_part: then_part,
            elif_parts: elif_parts,
            else_part: else_part,
            redirects: vec![],
        }
    }
}

ElifPart: ast::ElIf = {
    "elif" <condition: CompoundList> "then" <then_part: CompoundList> => {
        ast::ElIf {
            condition: condition,
            then_part: then_part,
        }
    }
}

ElsePart: Vec<ast::Term> = {
    "else" <term: CompoundList> => term,
}

simple_command: () = {
    CmdPrefix CmdWord CmdSuffix,
    CmdPrefix CmdWord,
    CmdPrefix,
    CmdName, CmdSuffix,
    CmdName,
}

CmdName: () = {
    Word,       // Apply rule 7a
}

CmdWord: () = {
    Word,       // Apply rule 7b
}

CmdPrefix: () = {
    IoRedirect,
    CmdPrefix IoRedirect,
    Assignment,
    CmdPrefix Assignment,
}

CmdSuffix: () = {
    IoRedirect,
    CmdSuffix IoRedirect,
    Word,
    CmdSuffix Word,
}

RedirectList: () = {
    IoRedirect,
    RedirectList IoRedirect,
}

IoRedirect: () = {
    FdRedirectDirection? IoFile,
    FdRedirectDirection? IoHere,
}

IoFile: () = {
    "<" Filename,
    "<&" Filename,
    ">" Filename,
    ">&" Filename,
    ">>" Filename,
    "<>" Filename,
    ">|" Filename,
}

Filename: () = {
    Word,       // Apply rule 2
}

IoHere: () = {
    "<<" HereEnd,
    "<<-" HereEnd,
}

HereEnd: () = {
    Word,       // Apply rule 3
}


SimpleCommand: ast::Command = {
    <assignment: Assignment*> <c: Argv0> => {
        // let mut argv = vec![c];
        // argv.append(&mut args);

        ast::Command::SimpleCommand {
            external: false,
            argv: vec![c],
            redirects: Vec::new(),
            assignments: assignment,
        }
    },

    <mut cmd: SimpleCommand> <arg: Word> => {
        match &mut cmd {
            ast::Command::SimpleCommand {
                external,
                argv,
                redirects,
                assignments,
            } => argv.push(arg),
            _ => unreachable!(),
        }
        cmd
    },

    <mut cmd: SimpleCommand> <direction: RedirectDirection> <to: Word> => {
        match &mut cmd {
            ast::Command::SimpleCommand {
                external,
                argv,
                redirects,
                assignments,
            } => {
                let mut redirect = ast::Redirection {
                    fd: match direction {
                        ast::RedirectionDirection::Input => 0,
                        _ => 1,
                    },
                    direction: direction,
                    target: ast::Word::redirection_type(to),
                };

                redirects.push(redirect);
            }
            _ => unreachable!(),
        }
        cmd
    },

    <mut cmd: SimpleCommand> <direction: FdRedirectDirection> <to: Word> => {
        match &mut cmd {
            ast::Command::SimpleCommand {
                external,
                argv,
                redirects,
                assignments,
            } => {
                let mut redirect = ast::Redirection {
                    fd: (direction.0.to_digit(10).unwrap() - '0'.to_digit(10).unwrap()) as i32,
                    direction: direction.1,
                    target: ast::Word::redirection_type(to),
                };

                redirects.push(redirect);
            }
            _ => unreachable!(),
        }
        cmd
    },

    <mut cmd: SimpleCommand> <direction: AndRedirectDirection> <to: Word> => {
        match &mut cmd {
            ast::Command::SimpleCommand {
                external,
                argv,
                redirects,
                assignments,
            } => {
                redirects.push(ast::Redirection {
                    fd: 2,
                    direction: direction.clone(),
                    target: ast::RedirectionType::Fd(1),
                });

                redirects.push(ast::Redirection {
                    fd: 1,
                    direction: direction,
                    target: ast::Word::redirection_type(to),
                });
            }
            _ => unreachable!(),
        }
        cmd
    },

    <mut cmd: SimpleCommand> <direction: "n>&n"> <to: Word> => {
        match &mut cmd {
            ast::Command::SimpleCommand {
                external,
                argv,
                redirects,
                assignments,
            } => {
                redirects.push(ast::Redirection {
                    fd: (direction.0.to_digit(10).unwrap() - '0'.to_digit(10).unwrap()) as i32,
                    direction: ast::RedirectionDirection::Output,
                    target: ast::RedirectionType::Fd((direction.1.to_digit(10).unwrap() - '0'.to_digit(10).unwrap()) as i32),
                });
            }
            _ => unreachable!(),
        }
        cmd
    },
}

Argv0: ast::Word = {
    Word,
}

RedirectDirection: ast::RedirectionDirection = {
    "<" => ast::RedirectionDirection::Input,
    ">>" => ast::RedirectionDirection::Append,
    ">|" => ast::RedirectionDirection::Output,
    ">" => ast::RedirectionDirection::Output,
}

AndRedirectDirection: ast::RedirectionDirection = {
//    "<&" => ast::RedirectionDirection::Input,
    "&>" => ast::RedirectionDirection::Output,
    ">&" => ast::RedirectionDirection::Output,
    "&>>" => ast::RedirectionDirection::Append,
}

FdRedirectDirection: (char, ast::RedirectionDirection) = {
    <ch: "n<"> => (ch, ast::RedirectionDirection::Input),
    <ch: "n>>"> => (ch, ast::RedirectionDirection::Append),
    <ch: "n>|"> => (ch, ast::RedirectionDirection::Output),
    <ch: "n>"> => (ch, ast::RedirectionDirection::Output),
}

Assignment: ast::Assignment = {
    <name: "TEXT"> <index: AssignIndex?> <append: AssignOp> <init: AssignInit> => {
        ast::Assignment {
            name: name.into(),
            initializer: init,
            index: index,
            append: append,
        }
    }
}

AssignInit: ast::Initializer = {
    "(" <w: Word*> ")" => {
        ast::Initializer::Array(w)
    },
    <w: Word> => {
        ast::Initializer::String(w)
    },
    Space => {
        ast::Initializer::String(ast::Word(vec![]))
    },
}

AssignOp: bool = {
    "=" => false,
    "=+" => true,
}

// index = { ("[" ~ (expr | index_all | command_substitution_span) ~ "]")? }


AssignIndex: ast::Expr = {
    "[" Expr "]" => ast::Expr::Literal(0),
}

Expr: ast::Expr = {
}

CommandSubstitutionSpan: ast::Word = {
}

Word: ast::Word = {
    double_quoted_span => ast::Word(vec![<>]),
    // "-?" => ast::Word(vec![ast::Span::Literal(format!("-{}", <>))]),
    // "[" => ast::Word(vec![ast::Span::Literal(String::from(<>))]),
    // "]" => ast::Word(vec![ast::Span::Literal(String::from(<>))]),
    <s:"TEXT"> => ast::Word(vec![ast::Span::Literal(String::from(s))]),
    ! => {
        let msg = format!("{:?}", <>);
        errors.push(<>);
        ast::Word(vec![ast::Span::Literal(msg)])
    },
}

double_quoted_span: ast::Span = {
    "\"" <span: literal_in_double_quoted_span> "\"" Space? => span,
}

literal_in_double_quoted_span: ast::Span = {
    <s: "TEXT"> => ast::Span::Literal(String::from(s)),
}

Num: i32 = {
    <s: "TEXT"> =>? i32::from_str(s)
            .map_err(|err| ParseError::User{
                error: lexer::Error::ParseIntError
            })
}

UnsignedNum: usize = {
    <s: "TEXT"> =>? usize::from_str(s)
            .map_err(|err| ParseError::User{
                error: lexer::Error::ParseIntError
            })
}

Space: () = {
    " "
}
